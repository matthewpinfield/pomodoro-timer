---
description: 
globs: 
alwaysApply: true
---

# Your rule content

This list is organized into categories for clarity and covers various aspects of software development and data science work.
I. Code Quality & Readability (Beyond Basic Style)
Clean Code Principles (Robert C. Martin's "Clean Code"):
Meaningful Names: Choose names for variables, functions, classes, and modules that are unambiguous, descriptive, and reflect their purpose. Avoid abbreviations and single-letter names (except for very common loop counters).
Functions Should Do One Thing: Functions should have a single, well-defined responsibility. This makes them easier to understand, test, and reuse.
Functions Should Be Small: Keep functions concise and focused. Long functions are harder to grasp and maintain.
Avoid Duplication (DRY - Don't Repeat Yourself): Extract common logic into reusable functions or classes. Duplication leads to maintenance nightmares and inconsistencies.
Comments When Necessary, Not as a Crutch: Code should be self-documenting as much as possible. Comments should explain why something is done, not just what the code is doing (which should be obvious from the code itself). Focus on explaining complex logic, edge cases, or design decisions.
Consistent Formatting (but let tools handle it): Use linters and formatters (like flake8, pylint, black for Python, eslint, prettier for JavaScript, etc.) to enforce consistent code style automatically. This reduces bikeshedding and improves readability across projects.
SOLID Principles of Object-Oriented Design (If applicable to your language/paradigm):
Single Responsibility Principle (SRP): A class should have only one reason to change.
Open/Closed Principle (OCP): Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.
Liskov Substitution Principle (LSP): Subtypes should be substitutable for their base types without altering the correctness of the program.
Interface Segregation Principle (ISP): Clients should not be forced to depend on interfaces they do not use.
Dependency Inversion Principle (DIP): Depend upon abstractions, not concretions.
KISS (Keep It Simple, Stupid) and YAGNI (You Ain't Gonna Need It):
Simplicity is Key: Favor simple, straightforward solutions over overly complex ones. Complexity increases the risk of bugs and makes maintenance harder.
Avoid Over-Engineering: Don't implement features or functionalities that are not currently needed. Focus on solving the immediate problem and add complexity only when necessary.
II. Efficiency and Performance (Beyond Basic Algorithm Choice)
Algorithm and Data Structure Selection: Choose algorithms and data structures that are appropriate for the task and scale of the data. Understand time and space complexity (Big O notation).
Profiling and Optimization (When Necessary):
Don't Optimize Prematurely: "Premature optimization is the root of all evil" (Donald Knuth). Focus on writing correct and readable code first.
Identify Bottlenecks: Use profiling tools to identify performance bottlenecks in your code. Don't guess where the problem is.
Targeted Optimization: Optimize only the parts of the code that are actually causing performance issues.
Consider Trade-offs: Optimization often involves trade-offs between performance, readability, and maintainability. Choose wisely.
Resource Management:
Memory Management: Be mindful of memory usage, especially in long-running applications or when dealing with large datasets. Avoid memory leaks. Understand garbage collection in your language.
CPU Usage: Write code that is CPU-efficient. Avoid unnecessary computations or loops. Consider parallelization or concurrency when appropriate.
Database Optimization: Write efficient database queries. Use indexes, optimize query plans, and consider database caching.
Network Efficiency: Minimize network requests and data transfer when working with distributed systems or APIs.
Asynchronous Programming and Concurrency (When Applicable): Understand and utilize asynchronous programming or concurrency techniques (threads, processes, async/await) to improve performance and responsiveness in I/O-bound or CPU-bound tasks.
III. Design and Architecture (Thinking at a Higher Level)
Modular Design and Abstraction:
Break Down Complexity: Divide your system into smaller, independent modules or components. This makes the system easier to understand, develop, and test.
Abstraction Layers: Create abstraction layers to hide implementation details and provide clear interfaces between modules. This promotes loose coupling and allows for changes in one module without affecting others.
Well-Defined APIs: Design clear and consistent APIs for your modules or services. APIs should be easy to use and understand.
Design Patterns (Understand and Apply Appropriately): Familiarize yourself with common design patterns (e.g., Singleton, Factory, Observer, Strategy, Decorator, etc.). Use them when they are appropriate to solve recurring design problems, but don't force them into situations where they don't fit.
Architectural Patterns (For Larger Systems): Understand different architectural patterns like:
Microservices: Breaking down an application into small, independent services.
Monolithic Architecture: A single, unified application.
Event-Driven Architecture: Systems that react to events.
Layered Architecture: Organizing code into distinct layers (presentation, business logic, data access).
Choose the Right Architecture: Select an architecture that is appropriate for the scale, complexity, and requirements of your project.
Separation of Concerns (SoC): Organize your code in a way that different concerns (e.g., data access, business logic, user interface) are handled by separate modules or components. This improves maintainability and testability.
IV. Testing and Quality Assurance (Beyond Unit Tests)
Comprehensive Testing Strategy:
Unit Tests: Test individual units of code (functions, classes) in isolation.
Integration Tests: Test the interactions between different modules or components.
End-to-End (E2E) Tests: Test the entire system from the user's perspective.
Regression Tests: Ensure that new changes do not break existing functionality.
Performance Tests: Measure the performance of your system under load.
Security Tests: Identify and address security vulnerabilities.
Test-Driven Development (TDD) or Behavior-Driven Development (BDD) (Optional but Recommended): Write tests before writing the code. This helps to clarify requirements, improve code design, and ensure testability.
Code Reviews: Have your code reviewed by peers. Code reviews are a crucial way to catch bugs, improve code quality, and share knowledge within a team.
Continuous Integration and Continuous Delivery (CI/CD): Automate the build, test, and deployment process. CI/CD pipelines help to ensure code quality, reduce errors, and speed up the delivery of software.
V. Collaboration and Communication (Essential for Teamwork)
Version Control (Git is the standard): Use version control to track changes to your code, collaborate with others, and revert to previous versions if necessary. Follow Git best practices (branching strategies, meaningful commit messages).
Code Reviews (As mentioned above): Participate actively in code reviews, both as a reviewer and a reviewee. Be constructive and focus on improving the code, not criticizing the person.
Clear and Concise Communication: Communicate effectively with your team members, stakeholders, and users. Be clear, concise, and respectful in your written and verbal communication.
Documentation (Beyond Code Comments):
API Documentation: Document your APIs clearly and comprehensively.
Design Documents: Document the design and architecture of your system.
README Files: Provide clear instructions on how to set up, run, and use your project.
User Manuals (If applicable): Document how users should interact with your software.
VI. Security Best Practices (Crucial for all applications)
Input Validation: Validate all user inputs to prevent injection attacks (SQL injection, cross-site scripting, etc.).
Secure Coding Practices (OWASP Top 10): Be aware of common security vulnerabilities and follow secure coding practices to mitigate them. Familiarize yourself with resources like the OWASP (Open Web Application Security Project).
Authentication and Authorization: Implement robust authentication and authorization mechanisms to protect sensitive data and resources.
Dependency Management and Security Scanning: Keep your dependencies up to date and use security scanning tools to identify and address vulnerabilities in your dependencies.
Data Encryption (At Rest and In Transit): Encrypt sensitive data both when it is stored (at rest) and when it is transmitted (in transit).
VII. Data Science Specific Best Practices (If applicable)
Reproducibility: Ensure that your data science workflows are reproducible. Use version control for code, data, and models. Document your environment and dependencies.
Data Cleaning and Preprocessing: Thoroughly clean and preprocess your data before analysis and modeling. Document your data cleaning steps.
Feature Engineering: Create meaningful features that improve the performance of your models. Document your feature engineering process.
Model Validation and Evaluation: Properly validate and evaluate your models using appropriate metrics and techniques (cross-validation, hold-out sets, etc.).
Ethical Considerations: Be aware of the ethical implications of your data science work, especially regarding bias, fairness, and privacy.
Model Versioning and Deployment: Version your models and have a clear process for deploying and monitoring them in production.
Data Governance and Lineage: Understand the source, quality, and lineage of your data. Implement data governance practices to ensure data quality and compliance.
